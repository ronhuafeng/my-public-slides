业务实践中除了让大模型生成代码，可能还需要大模型辅助进行错误调试、业务流程优化、运维等等。这些任务需要感知业务的运行状态，而将这些运行状态输入给大模型可能需要 MCP（或者手工复制粘贴给大模型也可以）。

我们可以通过下面的流程来实现这些目标：

- 使用第三方的 MCP 完成服务，这些第三方的 MCP 实现可能已经设计比较完善了
- 通过提示词注入，然后利用一些内置的通用 tool 去处理这些注入的提示。例如写入一些列服务启动、调试命令脚本在提示词，大模型可以通过 execute_command_line 工具或者 python_exec 依据提示去生成脚本来运行调试过程。

为什么要业务实践中自定义 MCP 服务？

- 首先这不是一个必须进行的操作，上面的方案在一定程度上能够完成任务

- 我们的目的是让整个过程更加可控，可以将多个步骤封装在 tool，减少大模型规划的压力
  - 例如将系统启动（docker compose）、用真实数据去请求系统响应、查看系统的日志（可能包含错误日志）这几个步骤封装成一个 tool。大模型在修改代码后，调用工具查看修改效果，然后可以根据系统的日志进行反馈，进一步对自己的修改进行迭代。
    - 这个可以用在代码优化、重构、缺陷调试中，可以有效构建一个大模型和真实系统间的反馈循环







## 项目总结 **proxy-in-middle**

**proxy-in-middle** 是一个功能强大的 MCP (Model Context Protocol) 代理服务器，其核心价值在于：

### 主要功能

1. **协议转换枢纽**：实现多种 MCP 传输协议间的无缝转换（stdio、SSE、WebSocket、Streamable HTTP）
2. **多服务器聚合**：将多个不同类型的 MCP 服务器统一到单一访问端点
3. **灵活部署**：支持本地子进程和远程服务器两种部署模式

### 技术特点

- **模块化设计**：每种协议转换都有独立的网关模块
- **配置驱动**：通过 JSON 配置文件管理所有服务器
- **高可用性**：包含自动重连、健康检查、会话管理等企业级特性
- **开发友好**：支持配置热重载、详细日志等开发调试功能

### 使用场景

- 为只支持 stdio 的 MCP 服务器提供 Web 接口
- 将多个分散的 MCP 服务器整合为统一的 API 网关
- 在不同的 MCP 客户端和服务器之间提供协议适配

我已经创建了一个简洁的架构示意图（[proxy-in-middle-architecture.drawio](vscode-file://vscode-app/Applications/Visual Studio Code.app/Contents/Resources/app/out/vs/code/electron-browser/workbench/workbench.html)），展示了从客户端到代理核心，再到协议网关和后端服务器的完整数据流。图中突出了项目的三个核心层：客户端接入层、协议转换层和服务器管理层。





## 项目功能总结 MCP SSE Proxy (frontend of proxy-in-middle)

**MCP SSE Proxy** 是一个强大的模型上下文协议(Model Context Protocol)网关代理系统，主要功能包括：

### 🎯 核心功能

1. **多协议网关** - 在 stdio、SSE、WebSocket、HTTP 等传输协议间进行无缝转换
2. **服务器聚合** - 将多个 MCP 服务器统一到单一端点，简化客户端访问
3. **可视化管理** - 基于 Next.js 的 Web 界面，提供配置管理和实时监控
4. **热配置重载** - 支持在不重启服务的情况下更新配置
5. **进程生命周期管理** - 自动管理子进程的启动、监控和清理

### 🏗️ 系统架构

- **Next.js Web 应用** - 用户友好的配置管理界面
- **代理服务核心** - TypeScript CLI 服务，负责协议转换和请求路由
- **协议网关层** - 12 种不同的协议转换网关实现
- **配置管理** - JSON 格式的灵活配置系统

### 🔄 支持的协议转换

- stdio ↔ SSE (Server-Sent Events)
- stdio ↔ WebSocket
- stdio ↔ HTTP 流式传输
- SSE ↔ WebSocket
- 配置文件 → 多种输出协议

我已经创建了一个简洁的架构示意图 [mcp-sse-proxy-architecture.drawio](vscode-file://vscode-app/Applications/Visual Studio Code.app/Contents/Resources/app/out/vs/code/electron-browser/workbench/workbench.html)，展示了系统的核心组件和数据流向。图中突出显示了：

- 用户通过 Web 界面进行配置管理
- 代理服务核心处理协议转换和请求路由
- 协议网关层提供多种输入输出协议支持
- 与外部 MCP 服务器和客户端的连接关系

这个系统的价值在于它消除了不同 MCP 传输协议间的兼容性障碍，让开发者可以灵活地在不同协议间进行转换，同时提供了统一的管理界面。

---

## Slide 1：标题页

**自定义 MCP 服务在业务系统中的实践**

* 演讲者：XXX
* 日期：2025.08.04

### 演讲稿

> 大家好，欢迎来到今天的分享。
> 我是\[姓名]，今天将和大家一起探讨如何从业务中提取大模型交互的需求，通过设计、实现自定义的 MCP （模型上下文协议）服务，并在业务系统中落地的过程。

---

## Slide 2：目录

1. MCP 概览：动机与价值
3. 自定义 MCP 的需求与痛点
4. 技术原理深度解析
5. 构建自定义 MCP 服务流程
6. 工具与配套服务示例
7. 业务案例：端到端演示
8. 性能与成果指标
9. 最佳实践与建议
10. 总结与 Q\&A

### 演讲稿

> 本次分享分为十个部分：
> 首先回顾 MCP 的核心价值，再看看 Cursor IDE 如何集成 MCP。
> 随后讨论为什么要自定义 MCP，以及技术底层；
> 然后进入实操：从需求到服务搭建，再到示例工具流水线；
> 最后用一个完整业务案例做端到端演示，并分享指标与最佳实践。

---

## Slide 3：MCP 概览：动机与价值

* 传统 LLM 局限：离线知识、无实时交互、无法执行操作
* MCP 解决：

  * **连接性**：打通 AI 与外部系统
  * **实时性**：获取最新数据、状态
  * **可操作性**：触发 API、脚本、部署流程
  * **定制化**：面向业务场景精准扩展

### 演讲稿

> 过去我们用 LLM 只能“对话”，却无法了解实时信息，也无法直接执行业务操作。
> MCP 协议的核心，是把模型“变身”为拥有真实操作能力的智能助手，既要拿到最新数据，也要驱动系统执行，并且可以按场景定制。

---

## Slide 4：Cursor IDE 中的 MCP 集成

* 架构：Cursor IDE ⇄ MCP 客户端 ⇄ MCP 服务端 ⇄ 业务系统
* 核心能力：

  * 扫描并发现配置的 MCP 服务
  * 能力协商：列出可用工具、资源、提示模板
  * 智能路由：根据意图挑选最优工具
  * 错误处理：超时重试与降级

### 演讲稿

> 在 Cursor IDE 中，只需在 `.cursor-settings/mcp.json` 中配置服务，IDE 会自动发现并协商能力。
> 当用户输入自然语言请求时，Cursor 解析意图，路由到对应工具，拿到结果后再呈现给用户，并且对失败场景做优雅处理。

---

## Slide 5：自定义 MCP 的需求与痛点

* 典型痛点：

  * 重复性高：代码审查、报告生成
  * 跨系统查询：多源数据聚合
  * 部署运维：脚本化、回滚
* 业务需求：

  1. **领域特定**：内部 API、专有格式
  2. **安全合规**：内网访问、权限审计
  3. **性能优化**：延迟与吞吐

### 演讲稿

> 为什么要自己编写 MCP 服务？
> 企业有很多场景需要定制：内部 API、特殊数据格式，以及安全合规的要求，都让“通用”服务无法满足。
> 同时，大量并发场景下对延迟和吞吐也要做针对性优化。

---

## Slide 6：技术原理深度解析

1. **JSON-RPC 2.0**

   * `method`: 工具名，如 `database_query`
   * `params`: 结构化参数
2. **资源（Resources）**

   * 文件、配置、统计数据
3. **提示模板（Prompts）**

   * 预设场景、可复用的提示
4. **工具（Tools）**

   * 单一职责、输入校验、幂等性

### 演讲稿

> MCP 基于 JSON-RPC，模型发起请求时，用 `method` 调用工具、通过 `params` 传入结构化参数。
> 资源描述、提示模板和工具定义共同构成了 MCP 能力集。
> 关键在于单一职责设计、严格校验输入、保证幂等性。

---

## Slide 7：构建自定义 MCP 服务流程

1. **需求定义**

   * 明确每个工具职责、输入输出规格
2. **协议与版本管理**

   * `server_info.version` 与 `protocolVersion`
3. **认证授权**

   * API Key、权限分级
4. **实现**

   * 接口规范 → 代码骨架 → 中间件（日志、超时）
5. **测试与调试**

   * 单元/集成/协议测试；结构化日志；链路追踪

### 演讲稿

> 整个服务构建从需求出发：先画出工具边界和参数，再定义协议版本号和认证方式。
> 代码实现时引入中间件统一管控日志与超时，最后通过多层测试和链路追踪保证可靠性。

---

## Slide 8：工具与配套服务示例

* **示例工具**：`check_project_health`

  * 输入：`project_path`、`include_security`
  * 输出：构建状态、测试覆盖率、安全扫描报告
* **服务链路**：

  1. MCP → CI 系统 API
  2. MCP → 静态代码扫描器
  3. MCP → 报告存储服务
* **辅助服务**：

  * 监控与告警
  * 缓存层（Redis）
  * 审计与审计日志

### 演讲稿

> 以 `check_project_health` 为例：它串联了三个后端服务——CI、扫描器、报告库。
> MCP 服务本身需要依赖缓存层来提升性能，并产生日志供审计和监控。

---

## Slide 9：业务案例：端到端演示

1. **场景**：新品上线前健康检查
2. **流程**：

   * 用户发起“检查项目健康”请求
   * MCP 服务调用多项子工具并行执行
   * 聚合结果并按模板生成报告
   * 报告存储到文档系统并触发通知
3. **关键代码片段**（示意）

### 演讲稿

> 这里演示一次完整业务流程：在新品版本上线前，自动触发健康检查，返回一个合格/不合格的报告，并推送到 Slack。
> MCP 服务并行执行各子任务，最后聚合成标准化文档，流程自动化全链路闭环。

---

## Slide 10：性能与成果指标

| 指标       | 优化前      | 优化后       | 提升      |
| -------- | -------- | --------- | ------- |
| 平均响应延迟   | 2.5 s    | 0.8 s     | 68% ↓   |
| 并发处理能力   | 50 req/s | 200 req/s | 300% ↑  |
| 调用成功率    | 92%      | 99.2%     | +7.8 pt |
| 重复任务自动化率 | 0%       | 90%       | —       |

### 演讲稿

> 量化效果：通过缓存、并行与降级策略，响应速度提升约 68%，并发能从 50 req/s 提升到 200 req/s。
> 自动化覆盖率达 90%，大幅降低了人工重复操作成本。

---

## Slide 11：最佳实践与建议

* **设计原则**

  * 单一职责、清晰接口、易扩展
* **开发方法**

  * 测试驱动、逐步迭代、文档优先
* **运维要点**

  * 监控告警、链路追踪、版本平滑升级
* **安全合规**

  * 最小权限、审计日志、加密存储

### 演讲稿

> 总结一下：保持工具粒度小且职责单一，先写测试再写代码，接口文档要完善。
> 生产环境要覆盖监控与链路追踪，并制定平滑升级与回滚策略，确保安全与可靠。

---

## Slide 12：总结与展望

* **MCP**：AI 与业务系统的桥梁
* **自定义**：满足企业特定安全、性能与流程需求
* **成功要素**：规范设计、完善测试、持续优化
* **未来方向**：AI 原生开发，行业标准化工具库，智能协作网络

### 演讲稿

> 今天我们看到了 MCP 的理念、原理和实战路径；
> 自定义 MCP 服务不仅能解放双手，还能提升业务效率与质量。
> 未来，我们期待更多 AI 原生的开发工具与标准化生态，共建智能协作网络。

---

## Slide 13：Q\&A

* 如何在现有 CI/CD 流程中引入 MCP？
* 针对高并发场景，哪些降级策略最有效？
* 鉴权与审计的最佳实践有哪些？
* ……

### 演讲稿

> 欢迎大家提问交流，也可以会后添加我的联系方式进一步探讨。
> 谢谢！
